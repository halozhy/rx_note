# 软需

> 教师信息: 李哲洙
>
> Email: lizhezhu@163.com

## 第一节课

### 软件开发会涉及到：

1. 过程&模型
2. 方法&技术
   1. 需求工程
   2. 项目管理
   3. 软件架构
3. 工具&环境
4. 标准&规范

这门课只涉及 “方法&技术”部分

### 推荐一本书

《人月神话》 <-  信仰！

### 项目成功的标尺

1. 规定的时间
2. 规定的成本
3. 达到/超过需求

### 我们最忌讳的：“三边行动”

边开发、边设计、边修改

### 我们能控制的

1. 利益关系人（别忘了政府）
2. 过程
3. 建模（UML）

> 结构化的开发方法：面向过程
>
> 面向对象的开发方法：**面向接口** <- OOP的核心

### 牢记一点：

“代码可增加，不可修改”（OCP原则）

## 第二节课

### 软件开发的生命周期

1. 需求分析
   1. 用户需求
   2. 功能需求
2. 系统设计
   1. 架构设计/系统设计
   2. 详细设计

3. 实现（写代码）
2. 集成、部署
3. 运维

### 需求获取（Requirements Elicitation）

**最困难、最关键、最易出错、最需交流**的环节

> 难点：
>
> 1. 交流能力、业务&领域知识能力
> 2. 无参照物
> 3. **与人沟通能力**

#### ✔业务需求

组织/机构对产品的高层次的目标需求

#### ✔用户需求

> 不管是什么需求，只要是用户提出的需求，就是用户需求

“**谁要什么样的东西**”

> 谁：用户主体
>
> 什么样：需求形式
>
> 东西：需求内容

#### 功能需求

**从用户需求到功能需求，必须经过需求分析**

系统必须实现的品质或者属性

⚠功能需求均为定性描述，我们需要通过场景化描述将其转为：定量描述

> 但是，非功能性需求对系统架构的影响更大

#### 技术需求

## 第三节课

### 需求获取流程

#### 收集相关资料

#### 系统相关人员分析

相关人员：直接或间接受益的人（**指用户方**）

> 利益关系人>相关人员

找到所有可能的需求源，因为：所有的软件都是给**人**用的

识别相关人员的方法：
1. 潜在的最终用户
2. 打算给予支持的人

不同层次的用户需求截然不同

#### 需求获取前准备

#### 应明确的问题和产品（**问问题**）

1. 需求目的，可行性描述
2. 限制性描述
3. 将来的设想
4. 明确服务器、客户机的软件硬件要求
5. 目前的用户
6. 将来最终操作人员的情况
7. 接口要求
8. 一组使用场景

先问全局性问题，再问细节问题

1. 具体的用户群体：员工、图书管理员，还有别人吗？
2. 系统的是使用是内网还是外网？服务器是否需要设在公司内部
3. 需要整合进已有的系统吗？希望做成什么形式，网页，APP……？
4. 一般会同时有多少个人在使用？
5. 具体怎么传递？怎么交接，以前是怎么样交接？是在一个工作站交接还是私下交接？ 
6. 员工的信息如何获取？
7. 通知的强度，是APP推送，还是发短信？
8. ~~假期怎么放~~

============================================================================

老师的问法：

1. 有员工信息管理系统吗？

   - 无：提问关于员工信息系统相关的问题……（需要自己做一个）

   - 有：我们的系统如何获取到员工信息？（员工信息管理系统对外的接口是什么？）

     ​	问关于系统间接口： 1.通信协议 2.数据内容（能得到哪些信息） 3.数据格式 4.数据同步（主动获取？/被动等待？）【订阅/发布】

2. 公司有没有期刊/图书管理系统？
   - 无：（需要自己做一个）
   - 有：接口是什么？……
3. 传阅的规则是什么？（问一些细节问题：图书丢失、员工请假……）

#### 需求获取的方法

任何一种方式都存在障碍

1. 访谈、问卷

   > 访谈：
   >
   > 沟通能力、沟通能力、沟通能力！
   >
   > 1. 提前准备好提纲
   >
   > 2. **提前把时间地点安排&提纲发给用户**（表达你的专业性）
   >
   >    时间：尽量周一上午、周五下午不要去！
   >
   >    地点：最不好的地方：客户的办公室（客户会受到太多的干扰）
   >
   >    ​			比较好的地方：小型的会客室，或者：茶楼、咖啡厅
   >
   >    ​			座位： 
   >
   >    <img src="C:\Users\Halo\AppData\Roaming\Typora\typora-user-images\image-20200928202645194.png" alt="image-20200928202645194" style="zoom:50%;" />
   >
   >    ​			最好是坐在客户旁边（同性之间），营造出一种共同讨论问题的氛围
   >
   > 3. 着装：干练整洁
   >
   > 4. 肢体语言
   >
   > 5. 去几个人？2人协同（最好包括你自己）
   >
   > 6. 最好录个音😂
   >
   > 7. 回头整理一份调研报告，之后仍要**发给用户确认**（表达你的专业性）
   >
   > 问卷：
   >
   > ​	开放性问题（5W问题）或者，半开放：选择题
   >
   > 1. 设计问卷
   > 2. 预先小范围测试
   > 3. 广泛发布、收集、统计

2. 会议

   > 1. 会前准备
   >
   >    有关资料、通知与会成员
   >
   > 2. 会中控制/执行
   >
   >    1. 最好设一位主持（主席）：控制会议的进程（防跑题）
   >
   >    2. 控制会议时长（1.5h为宜，长时间会议中途一定要休息一下）
   >    3. 控制发言顺序、发言时长
   >
   > 3. 会后总结
   >
   >    做好会议纪要（做了什么、哪些没做等），会议纪要写好之后要发给一两个人确认一下，之后发布给所有与会人员（表达你的专业性）

3. 文档研究

   > 可以交叉检查访谈的成果是否准确
   >
   > **⚠谨防文档过期、或者与现实不符⚠**
   >
   > 1. 用户公司的规章制度、国家的法律法规（税收系统要研究税收政策……）
   > 2. 工作手册、工作流程
   > 3. 工作/岗位的职责
   > 4. 报表，文件

4. 任务示范（观察）：**⚠表现可能和实际情况不符⚠**

5. 用例、角色扮演

6. 原型设计（小规模实验）：在需求不太明确的时候使用，先做出一个demo看看

7. 研究类似公司

#### 整理记录需求、以及记录需求的理由

## 第四节课

> 显性需求、**隐性需求**

为了解决软件的不可见性，往往会用以下方法：

1. 原型开发：最难处理真实的是“数据”
2. 敏捷开发（常见于 to C 的项目）：依赖快速迭代

### 业务建模，挖掘隐性需求

#### 目标

总体目标还是获取：用户需求

1. 理解当前问题，识别改进机会
   
	> 主要就是：解决**痛点**

2. 确保客户、最终用户、开发人员和其它伙伴对目标有共同的理解

3. 抽取软件系统的需求

#### 范围

结构化方法：

1. 信息建模（ER图）

 	2. 流程建模（DFD图）

面向对象的方法：

 1. 用例建模 -> 得到用例模型

    

✔领域模型：开发信息密集时

✔业务流程模型

✔组织图

✔系统环境模型：确定系统范围

通用业务模型：多个组织同时使用，存在多种业务





#### 步骤：

##### 一、系统环境模型-上下文图

​	概括出产品的必要接口：

1. 系统间接口（对外接口）
       1. 通讯协议
       2. 数据内容
       3. 同步方式
2. 组件间接口
3. 类间接口
4. 人机接口

​	用户画像（用户特点）-> 系统的易用性、友好性

​	应用环境

##### 二、业务流程建模-活动图

1. 了解业务，画流程图

2. 通过流程图和用户交流

3. 最后由用户确认流程图

> 流程具有层次：
>
> - 嵌套的流程图
>
> - 宏观、微观
>
> 业务的开始是流程的入手点



###  类之间的关系

依赖 < 关联 < 聚合 < 组合 < 继承

> 一般来说，依赖只在编程时体现，设计时不考虑



## 第五节课

**功能&技术需求的成果物：软件需求分析说明书**

> 这个说明书里面应该包括：
>
> 1. 用例图
> 2. 用例详述
> 3. 活动图
> 4. 主要原型界面

### 用例建模的目的和作用

1. **可视化（场景化）**

   > ⚠可视化和场景化是用例建模的重要作用

2. 契约

3. 形成《用户手册》的初稿

4. 形成测试用例的初稿（因为没有测试数据，所以只能是初稿）

### 用例建模的步骤和流程

1. 确定系统范围（系统环境模型）

2. 识别参与者

   参与者：直接与系统交互的事务所扮演的角色，包括了：

   - 人
   - 其它系统
   - 硬件系统
   - 时钟

   每个参与者需有一个具有业务意义的简短名称、以及一个简短的描述（也是为了完成“数据字典”，以及明确最终用户 ->友好型易用性）

   eg 学生：东北大学软件学院在籍的学生

   > 利益关系人：与项目利益有关的所有人，既有正相关也有负相关
   >
   > 相关人员：直接或间接和项目利益正相关的人
   >
   > 参与者：可以理解成最终用户（不过最终用户只是参与者的一部分）
   >
   > <img src="C:\Users\Halo\AppData\Roaming\Typora\typora-user-images\image-20201019192233770.png" alt="image-20201019192233770" style="zoom: 67%;" />
   >
   > 相关人员和参与者的交集：和系统有直接正相关利益的人

3. 识别用例

   为什么要先识别参与者，再识别用例？保持面向对象的思想（以人为本）

   用例是参与者想要系统做的事情，是参与者和系统的一系列交互

   **用例模型是用用户可以理解的语言编写的**（业务语言）

   识别用例是用：用例图（User Case Diagram）来呈现

   用例模型编写（绘制）完成之后，需要给用户展示，以完成**需求确认**

4. 用例详述

   > 模板：
   >
   > 1. 用例名称：动+名/名+动 eg 新增学生信息
   > 2. 用例简述
   > 3. 参与者
   > 4. 前置条件 eg 新增学生信息
   > 5. 事件流：用例图里面的主要内容
   >    - 使用一般陈述句
   >    - 避免不明确的术语
   > 6. 控制流

## 第六节课

### 用例模型的内容

> //详见：上面软件需求分析说明书内应包含的内容

### 用例建模与开发模式的关系

开发方法和开发模式应当匹配

常见的开发模式：

1. 瀑布式开发

2. 敏捷开发
3. 增量迭代
4. DevOps

**增量迭代的开发模式 **- 比较符合OOP的思想

1. 先对用例划分优先级：划分为：高、中、低

   > 用例优先级的划分依据：业务需求

2. 主事件流和次事件流划分到不同周期

3. 细化用例模型结构：

   > 把一个用例分成：基本用例+xx用例
   >
   > 用例间的扩展关系：
   >
   > 画图箭头指向：扩展谁指向谁
   >
   > 扩展用例：满足某种条件时，才可以执行的用例
   >
   > 用例间的包含关系：
   >
   > 画图箭头指向：包含谁指向谁
   >
   > 包含用例：基本用例执行时，包含用例就执行
   >
   > 
   >
   > 无论细化什么用例模型：尽可能保证能被更多的复用

   

   //关于加班

   假设工期只有90天

   去掉5%~15%的时间（这些时间作为应急时间），然后设置DDL ->81天

   从后往前排时间（美其名曰：“靠墙不倒”）

   调整工序，尽可能并行处理 -> -10天

   那么加班时间暂且为：10d

   10 * 8h/d = 80h

   80 /  (4 * 70%) = 29d  //假设加班时，一天工作4h。4h再乘70%是因为，只有70%左右的时间才能真正专注下来

   

   谁来加班？

   项目中“关键路径”的人员加班  //“关键路径”指的是工期最长的那条路径

   加班的人也不宜多，少而精  //让加班人员有自豪感😂



### 行为模型

OOP分析的主要工作

1. 用例模型

2. 概念模型

3. 动态模型（行为模型）

### 概念模型（问题域模型）

分析类：是对问题域中的简洁抽象

方法：名称动词法：名词->对象/属性，动词->类间关系/方法